ammo.js
=======


**Demo: http://syntensity.com/static/ammo.html**

**Example code to give you an idea of the API: https://github.com/kripken/ammo.js/blob/master/examples/webgl_demo/ammo.html#L14**

ammo.js is a direct port of the Bullet physics engine to JavaScript, using Emscripten. The source code is translated directly to JavaScript, without human rewriting, so functionality should be identical to the original Bullet.

'ammo' stands for "Avoided Making My Own js physics engine by compiling bullet from C++" ;)

ammo.js is zlib licensed, just like Bullet.

Discussion takes place on IRC at #emscripten on Mozilla's server (irc.mozilla.org)


Instructions
------------

builds/ contains prebuilt versions of ammo.js:

 * ammo.js: Optimized and minified build. This is probably what you want.
 * ammo.slow.js: A very slow debug version. This includes many runtime checks and safety measures.

You can also build ammo.js yourself, as follows:

 * Get Emscripten

      http://emscripten.org

   and set it up. See

      https://github.com/kripken/emscripten/wiki/Getting-started

 * Run the build script,

      python make.py

   which should generate builds/ammo.new.js. Note that this
   is by default an unoptimized safe build which will run very slowly.
   You can run make.py with argument |fast| to generate an optimized
   make.

 * Run the automatic tests,

      python test.py


Usage
-----

The most straightforward thing is if you want to write your code in C++, and
run that on the web. If so, then compile your code into LLVM, link it with
bullet, and compile that to JavaScript using emscripten. (The easiest way to
link it is to add your .bc file to the llvm-link command in make.py.)

If, on the other hand, you want to write code in JavaScript, you can use the
autogenerated binding code. A complete example appears in

  examples/hello_world.js

That is HelloWorld.cpp from Bullet, translated to JavaScript. Other examples
in that directory might be useful as well. In particular see the webgl
demo code in

  examples/webgl_demo/ammo.html


API Differences
===============

ammo.js autogenerates its API from the Bullet source code, so it should
be basically identical. There are however some differences:

  * Functions returning or getting float& or btScalar& are converted to
    float. The reason is that float& is basically float* with nicer syntax
    in C++, but from JavaScript you would need to write to the heap every
    time you call such a function, making usage very ugly. With this change,
    you can do |new btVector3(5, 6, 7)| and it will work as expected. If
    you find a case where you need the float& method, please file an issue.

  * Not all classes are exposed, for various reasons. Please file an issue
    if you find that something you need is missing.

  * Each call to |new X()| will leak. We have not integrated C++
    memory management with the JavaScript GC yet.

  * Functions that return an entire object, like |btQuaternion someFunc()|,
    will return a reference to a static object held inside the binding
    function. That means that you cannot call the binding function multiple
    times and still use the values - you must copy them.

  * All the bindings functions expect to receive wrapper objects, that
    contain the raw pointer inside them (.ptr). If you have a raw pointer,
    wrap it by calling CLASSNAME__wrap(ptr) where CLASSNAME is the class name.
    If you want to pass a null pointer, use NULL which is a wrapper object
    defined for that purpose (with ptr == 0). The reason for this is that
    the bindings code is faster if it does not need to check each argument
    for its type and convert them on the fly. In practice this should not be
    an inconvenience, and you shouldn't need to think about it, because
    bindings functions return wrapped objects, so you can just pass those
    back into other bindings functions. In other words, you should normally
    never have to see a raw pointer.


Reporting Issues
================

If you find a bug in ammo.js and file an issue, please test your code
with the slow unoptimized build in builds/ammo.slow.js too, and mention
in the issue how that works (the optimized build applies a few speculative
speedups that can, in theory, break things; the slow build is safer).

