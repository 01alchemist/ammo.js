ammo.js
=======

ammo.js is a direct port of the Bullet physics engine to JavaScript, using Emscripten. The source code is translated directly to JavaScript, without human rewriting, so functionality should be identical to the original Bullet.

AMMO might stand for "Avoided Making My Own js physics engine by compiling bullet from C++" ;) credit to ccliffe for the name.

ammo.js is zlib licensed, just like Bullet.

Discussion takes place on IRC at #emscripten on Mozilla's server (irc.mozilla.org)


Status
------

ammo.js works, see a demo at

  http://syntensity.com/static/bullet.html


Instructions
------------

Stable ammo.js files will be available soon. Meanwhile, you can build it yourself, as follows:

 * Get Emscripten

      http://emscripten.org

   and set it up. See

      https://github.com/kripken/emscripten/wiki/Getting-started

 * Run the build script,

      ./build.py

   which should generate bullet/build/libbullet.js. Note that this
   is by default an unoptimized build which will run very slowly.
   See build.py for optimizations.

 * Run the test,

      python test.py


Usage
-----

The most straightforward thing is if you want to write your code in C++, and
run that on the web. If so, then compile your code into LLVM, link it with
bullet, and compile that to JavaScript using emscripten. (The easiest way to
link it is to add your .bc file to the llvm-link command in build.py.)

If, on the other hand, you want to write code in JavaScript, you can use the
autogenerated binding code. A complete example appears in

  examples/hello_world.js

That is HelloWorld.cpp from Bullet, translated to JavaScript.


API Differences
===============

ammo.js autogenerates its API from the Bullet source code, so it should
be basically identical. There are however some differences:

  * Functions returning or getting float& or btScalar& are converted to
    float. The reason is that float& is basically float* with nicer syntax
    in C++, but from JavaScript you would need to write to the heap every
    time you call such a function, making usage very ugly. With this change,
    you can do |new btVector3(5, 6, 7)| and it will work as expected. If
    you find a case where you need the float& method, please file an issue.

  * Not all classes are exposed, for various reasons. Please file an issue
    if you find that something you need is missing.

  * Each call to |new X()| will leak. We have not integrated C++
    memory management with the JavaScript GC yet.

