<html>
    <head>
      <title>Bullet/WebGL Demo</title>
      <script src="CubicVR.js" type="text/javascript"></script>
      <script src="../../builds/ammo.js" type="text/javascript"></script>
      <style type="text/css">
        body { background-color: #ccc; }
      </style>

      <script type="text/javascript">
        var NUM = 5;
        var NUMRANGE = [1,2,3,4,5];

        // Bullet-interfacing code

        var collisionConfiguration = new btDefaultCollisionConfiguration();
        var dispatcher = new btCollisionDispatcher(collisionConfiguration);
        var overlappingPairCache = new btDbvtBroadphase();
        var solver = new btSequentialImpulseConstraintSolver();
        var dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
        dynamicsWorld.setGravity(new btVector3(0, -10, 0));

        var groundShape = new btBoxShape(new btVector3(50, 50, 50));

        var bodies = [];

        var groundTransform = new btTransform();
        groundTransform.setIdentity();
        groundTransform.setOrigin(new btVector3(0, -56, 0));

        (function() {
          var mass = 0;
          var localInertia = new btVector3(0, 0, 0);
          var myMotionState = new btDefaultMotionState(groundTransform);
          var rbInfo = new btRigidBodyConstructionInfo(0, myMotionState, groundShape, localInertia);
          var body = new btRigidBody(rbInfo);

          dynamicsWorld.addRigidBody(body);
          bodies.push(body);
        })();

        var boxShape = new btBoxShape(new btVector3(1, 1, 1));

        NUMRANGE.forEach(function(i) {
          var startTransform = new btTransform();
          startTransform.setIdentity();
          var mass = 1;
          var localInertia = new btVector3(0, 0, 0);
          boxShape.calculateLocalInertia(mass, localInertia);
        
          var myMotionState = new btDefaultMotionState(startTransform);
          var rbInfo = new btRigidBodyConstructionInfo(mass, myMotionState, boxShape, localInertia);
          var body = new btRigidBody(rbInfo);

          dynamicsWorld.addRigidBody(body);
          bodies.push(body);
        });

        function resetPositions() {
          NUMRANGE.forEach(function(i) {
            var body = bodies[i];
            var origin = body.getWorldTransform().getOrigin();
            origin.setX((Math.random()-0.5)*2);
            origin.setY(4+i*2.5);
            origin.setZ((Math.random()-0.5)*1);
            body.activate();
          });
        }

        resetPositions();

        var trans = new btTransform(); // taking this out of readBulletObject reduces the leaking
        function readBulletObject(i, pos, quat) {
          var body = bodies[i];
          body.getMotionState().getWorldTransform(trans);
          var origin = trans.getOrigin();
          pos[0] = origin.x();
          pos[1] = origin.y();
          pos[2] = origin.z();
          var rotation = trans.getRotation();
          quat.x = rotation.x();
          quat.y = rotation.y();
          quat.z = rotation.z();
          quat.w = rotation.w();
        }

        function noneActive() {
          var num = 0;
          NUMRANGE.forEach(function(i) {
            var body = bodies[i];
            num += body.isActive();
          });
          return num == 0;
        }

        // Main demo code

        var boxes = [];

        function simulatePhysics(dt) {
          dynamicsWorld.stepSimulation(dt, 2);

          // Read bullet data into JS objects
          var pos = [0,0,0];
          var quat = new CubicVR.Quaternion;
          for (var i = 0; i < NUM; i++) {
            readBulletObject(i+1, pos, quat);
            var renderObject = boxes[i];
            renderObject.position[0] = pos[0];
            renderObject.position[1] = pos[1];
            renderObject.position[2] = pos[2];
            renderObject.rotation = quat.toEuler();
          }
        }

        var dts = 0, num = 0, lastHUD = Date.now();

        function showFPS(dt) {
          var now = Date.now();
          dts += dt;
          num++;
          if (now - lastHUD > 333) {
            document.getElementById('out').innerHTML = '<b>FPS: ' + Math.ceil(1/(dts/num)) + '</b>';
            lastHUD = now;
            dts = 0;
            num = 0;
          }
          t = now;
        }

        function startUp() {
          var canvas = document.getElementById("canvas");
          canvas.width = screen.width*0.70;
          canvas.height = screen.height*0.55;

          gl = CubicVR.GLCore.init(canvas, "CubicVR_Core.vs", "CubicVR_Core.fs");

          if (!gl) {
            alert("Sorry, no WebGL support :(");
            return;
          };

          var scene = new CubicVR.Scene(canvas.width, canvas.height, 70);
          var light = new CubicVR.Light({
            type: CubicVR.enums.light.type.POINT,
            method: CubicVR.enums.light.method.DYNAMIC,
            diffuse: [1, 1, 1],
            specular: [0.25, 0.25, 0.25],
            position: [0, 5, 20],
            distance: 200
          });
          scene.bindLight(light);

          scene.camera.position = [0, 2.4, 17];
          scene.camera.target = [0, 2.4, 0];

          var boxMaterials = NUMRANGE.map(function(i) {
            return new CubicVR.Material({
              textures: {
                color: new CubicVR.Texture("cube" + i + ".jpg")
              }
            });
          });

          var boxMeshes = boxMaterials.map(function(boxMaterial) {
            return new CubicVR.primitives.box({
              size: 2.0,
              material: boxMaterial,
              uvmapper: {
                projectionMode: CubicVR.enums.uv.projection.CUBIC,
                scale: [2, 2, 2]
              }
            }).triangulateQuads().compile().clean();
          });

          for (var i = 0; i < NUM; i++) {
            boxes[i] = new CubicVR.SceneObject({ mesh: boxMeshes[i], position: [0, -10000, 0] });
            scene.bindSceneObject(boxes[i], true);
          }

          var FLOOR_SIZE = 100;
          var floorMaterial = new CubicVR.Material({
            textures: {
              color: new CubicVR.Texture("cube3.jpg")
            }
          });
          var floorMesh = new  CubicVR.primitives.box({
            size: FLOOR_SIZE,
            material: floorMaterial,
            uvmapper: {
              projectionMode: CubicVR.enums.uv.projection.CUBIC,
              scale: [FLOOR_SIZE, FLOOR_SIZE, FLOOR_SIZE]
            }
          }).triangulateQuads().compile().clean();

          var floor_ = new CubicVR.SceneObject({ mesh: floorMesh, position: [0, -FLOOR_SIZE/2-6, 0] });
          scene.bindSceneObject(floor_, true);

          function checkRestart() {
            if (noneActive()) restart();
          }

          var mvc = new CubicVR.MouseViewController(canvas, scene.camera);

          CubicVR.MainLoop(function(timer, gl) {
            var dt = timer.getLastUpdateSeconds();
            simulatePhysics(dt);
            checkRestart();
            scene.render();
            showFPS(dt);
          });
        }

        function restart() {
          totalTime = 0;
          resetPositions();
        }
      </script>
    </head>
    <body onload="startUp()">
      <center>
        <h2>ammo.js WebGL Demo</h2>

        <canvas id="canvas" width="600" height="500"></canvas>
        <br><br>
        <div id="out">waka</div>
        <p>
        This is <b><a href="https://github.com/kripken/ammo.js">ammo.js</a></b>, a port of
        the <b><a href="http://www.bulletphysics.com">Bullet physics engine</a></b> from C++ to JavaScript
        using <b><a href="http://emscripten.org">Emscripten</a></b>. WebGL rendering in this demo is done using
        <b><a href="https://github.com/cjcliffe/CubicVR.js/">CubicVR.js</a></b>.
        </p><p>
        Adjust the view by dragging the mouse over the canvas.
        </p>
      </center>
    </body>
</html>

