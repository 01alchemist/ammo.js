
// Linear Math

interface btVector3 {
  void btVector3();
  void btVector3(float x, float y, float z);
  float x();
  float y();
  float z();
  [Operator="*=", Ref] btVector3 op_mul(float x);
};

interface btVector4 {
  void btVector4();
  void btVector4(float x, float y, float z, float w);
  float w();
};
btVector4 implements btVector3;

interface btQuadWord {
  float x();
  float y();
  float z();
  float w();
};

interface btQuaternion {
  void btQuaternion(float x, float y, float z, float w);
};
btQuaternion implements btQuadWord;

interface btTransform {
  void btTransform();
  void btTransform([Ref] btQuaternion q, [Ref] btVector3 v);

  void setIdentity();
  [Ref] btVector3 getOrigin();
  [Value] btQuaternion getRotation();
};

interface btDefaultMotionState {
  void btDefaultMotionState([Ref] optional btTransform startTrans, [Ref] optional btTransform centerOfMassOffset);
};

// Collision

[Prefix="btCollisionWorld::"]
interface RayResultCallback {
  // abstract base class, no constructor
};

[Prefix="btCollisionWorld::"]
interface ClosestRayResultCallback {
  void ClosestRayResultCallback([Ref] btVector3 from, [Ref] btVector3 to);
};

ClosestRayResultCallback implements RayResultCallback;

interface btCollisionShape {
};

interface btBoxShape {
  void btBoxShape([Ref] btVector3 boxHalfExtents);
};

interface btMotionState {
};

[Prefix="btRigidBody::"]
interface btRigidBodyConstructionInfo {
  void btRigidBodyConstructionInfo(float mass, btMotionState motionState, btCollisionShape collisionShape, [Ref] optional btVector3 localInertia);
};

interface btRigidBody {
  void btRigidBody([Ref] btRigidBodyConstructionInfo constructionInfo);
};

// Dynamics

interface btPoint2PointConstraint {
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btVector3 pivotInA, [Ref] btVector3 pivotInB);
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Ref] btVector3 pivotInA);
};

