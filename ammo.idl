
// Linear Math

interface btVector3 {
  void btVector3();
  void btVector3(float x, float y, float z);
  float x();
  float y();
  float z();
};


interface btVector4 {
  void btVector4();
  void btVector4(float x, float y, float z, float w);
  float w();
};
btVector4 implements btVector3;

interface btQuaternion {
  void btQuaternion(float x, float y, float z, float w);
};
btQuaternion implements btVector4; // this seems wrong? btQuadWord?

interface btTransform {
  void btTransform();
  void btTransform([NonPointer] btQuaternion q, [NonPointer] btVector3 v);

  void setIdentity();
  [NonPointer] btVector3 getOrigin();
  [Copy] btQuaternion getRotation();
};

interface btDefaultMotionState {
  void btDefaultMotionState([NonPointer] optional btTransform startTrans, [NonPointer] optional btTransform centerOfMassOffset);
};

// Collision

[Prefix="btCollisionWorld::"]
interface RayResultCallback {
  // abstract base class, no constructor
};

[Prefix="btCollisionWorld::"]
interface ClosestRayResultCallback {
  void ClosestRayResultCallback([NonPointer] btVector3 from, [NonPointer] btVector3 to);
};

ClosestRayResultCallback implements RayResultCallback;

interface btCollisionShape {
};

interface btBoxShape {
  void btBoxShape([NonPointer] btVector3 boxHalfExtents);
};

interface btMotionState {
};

[Prefix="btRigidBody::"]
interface btRigidBodyConstructionInfo {
  void btRigidBodyConstructionInfo(float mass, btMotionState motionState, btCollisionShape collisionShape, [NonPointer] optional btVector3 localInertia);
};

interface btRigidBody {
  void btRigidBody([NonPointer] btRigidBodyConstructionInfo constructionInfo);
};

// Dynamics


